package com.mmr.learn.thread.lesson14;

/**
 * Description: 等待通知机制
 * User: MaMingRui
 * Email: mamr@broada.com
 * Date: 2019年02月25日 10:13
 * ModificationHistory: Who         When         What
 * ---------  --------     ---------------------------
 */
public class Entrance {
    /**
     *  [项目列表]
     *  <t1> 不使用等待/通知机制，直接使用sleep()结合while(true)死循环来实现线程间的通信
     *     TODO jdk1.6版本和jdk1.7以上版本下执行的结果完全不同。jdk1.6，当list中被添加5个元素后，ThreadB能成功获取到list的值，但jdk1.7和1.8不行。请问这是为什么？
     *     思考: 虽然两个线程之间实现了通信，但弊端在于，ThreadB不断地通过while()语句轮询机制来监测某一个条件，这样会浪费CPU资源
     *           如果轮询的时间间隔很小，更浪费CPU。如果轮询时间间隔过长，很可能取到意想不到的数据。
     *           所以现在就需要一种机制，既能减少CPU的资源浪费，又能实现多线程之间的通信。
     *           故，"wait/notify"机制应运而生。
     *  <t2> 若不在synchronized内使用wait()，会抛出 java.lang.IllegalMonitorStateException
     *     思考: 若没有获取监视器，也就是没有在同步块内加锁，就会抛异常。
     *  <t3> t2的改良版，正确的使用wait()
     *     思考: t3的确可以运行，但这样会永远等待下去，程序也永远停滞不前，那么如果使wait状态的线程继续执行呢？答案就是notify()方法。
     *  <t4> wait/notify方法小用例
     *     思考: 本案例中我特意在ThreadB的notify下 停止当前线程运行3秒钟，发现即便已经对lock锁对象调用了notify()方法，ThreadA不会立刻从wait()
     *           状态中恢复运行，而是直到ThreadB的run()运行结束后，才恢复运行。
     *  <t5> 使用wait/notify改造t1项目
     *  <t6> 当方法wait()被执行后，锁被自动释放，但执行完notify()后，锁不会被释放。
     *     思考:
     *          1. wait()执行后自动释放锁，而sleep()执行后不会释放掉当前线程持有的锁，也即其它线程都无法获得该线程占住的同步代码块。
     *          2. 必须执行完notify()方法所在的同步代码块内所有代码后，该线程才会释放锁。
     *  <t7> 当interrupt()遇见wait()时会产生怎样的火花呢
     *     思考: 执行后发现Thread.wait()方法被InterruptedException异常捕获了。
     *
     *   ===============总结上述案例===============
     *   1. 执行完同步代码块就会释放掉对象的锁。
     *   2. 在执行同步代码块的过程中，遇到异常而导致线程终止，其所持的锁也会被释放。
     *   3. 在执行同步代码块的过程中，如果执行了锁所属对象的wait()方法，这个线程会释放对象锁，而此线程对象会进入线程等待池中，等待被唤醒。
     *
     *  <t8> 只通知一个线程
     *     思考:
     *     1. 虽然理论上调用方法notify()一次仅"随机"通知一个线程进行唤醒。 但经过我多次试验，一般停下来的都是优先级最高的。
     *     2. 多次调用notify()方法会"随机"的等待wait状态的线程进行唤醒。
     *
     *     notifyAll()可以唤醒所有因当前锁而被阻塞的线程。
     *
     *     wait(long) 可以传入时间，比如 wait(5000)  等待5秒后线程恢复成Runnable状态，同样的，我们也可以在线程等待3秒的时候就把线程唤醒。
     *   <t9> 当然了，通知过早也不是什么好事情，下面让我们来看看通知过早引发的后果。
     *       如果先进行了notify()，那么后面被wait()的线程将得不到恢复
     *   <t10> 是<t9>的改良版，仍然先进行notify()，请看结果。
     *       思考: 其实就是取巧，借助共享变量isFirstRun，使 lock.wait();得不到执行。
     *   <t11> 在使用wait/notify模式时，还需要注意另外一种情况——wait等待时，后续的条件发生了变化，也容易造成程序逻辑的混乱。
     *       思考: 起初subtract1Thread和subtract2Thread启动后都会阻塞到wait()方法处，接着ThreadAdd运行后唤醒了所以由lock而wait()的方法，在list中新增了一条数据。
     *             而那么subtract1Thread的确能删除list中索引为0的数据，但是list局没有了留给subtract2Thread删除的数据了，因此调用list.remove()时报错。
     *   <t12> notify/wait模式最经典的案例来了！------"生产者/消费者"模式。
     *       思考:
     *             1. 一个生产者 & 一个消费者
     *             2. 一个生产者 & 多个消费者
     *             3. 多个生产者 & 一个消费者
     *             4. 多个生产者 & 多个消费者
     *             如果有多个生产者或多个消费者时，很容易出现假死的情况。出现的原因在于，你无法保证每次唤醒的线程恰好是异类线程。
     *             比如作为"生产者"，我的理想唤醒线程是"消费者"，但notify()方法是随机唤醒一个线程，因此如果唤醒的是其它"生产者"线程，就会造成这条线程也进入等待状态。
     *             解决方案: 使用notifyAll()来替代notify()， 唤醒所有线程即可。
     *
     *
     *   <t13> 通过管道进行线程之间的通信 --- 字节流
     *        思考:
     *             前面的案例都是通过某个共享变量来实现线程之间的通信，那么还有没有其它手法呢？当然是有的。
     *             Java专门针对线程通信提供了两组"管道流":
     *             1. PipedInputStream和PipedOutputStream
     *             2. PipedReader和PipedWriter
     *             一个线程发送数据至输出管道，另一个线程从输入管道中读取数据。
     *
     *             使用代码inputStream.connect(outputStream)或者outputStream.connect(inputStream)的作用是使两个管道流之间产生通信连接。
     *             如果上述两条代码都写了，会报错: java.io.IOException: Already connected
     *             值得一提的是，int readLength = input.read(byteArrays);  其中，input.read()方法是一个阻塞方法，当且仅当管道内有数据时，才继续向下运行。
     *
     *   <t14> 通过管道进行线程间通信 --- 字符流
     *        思考: 与字节流基本类似，都是需要建立连接
     *              务必记得实现Thread类的super()方法
     *
     *   <t15> 实战---等待/通知之交叉备份
     *         题目: 创建20个线程，其中10个线程是将数据备份到数据库A中，另外10个线程是将数据备份到数据库B中，并且备份A和B数据库是交叉运行的。
     *                这个题目的核心技巧在于，通过volatile变量使线程之间通信，通过notifyAll()唤醒所有线程，并有针对性的运行线程。
     *
     */
}
