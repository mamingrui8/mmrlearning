package com.mmr.learn.thread.topic;

public class Entrance {
    /**
     * 1. 什么是Java中的原子性
     *    答: 原子操作是指本次操作不会被任何其他线程调度机制打断的操作。这种操作一旦开始，就会一直运行到结束，中间不会有任何的context switch (切换到另一个线程)
     * 2. 什么是Java中的CAS操作， AtomicLong的实现原理是什么？
     *    答: CAS(Compare And Set) 其作用是对某一个变量进行原子化更新操作。
     *        该算法的思想是:
     *        CAS(v, e, u)
     *        -- v: 待更新的变量
     *        -- e: 变量的预期值
     *        -- u: 变量的新值
     *        1. 当且仅当v的实际值等于e值时，才把u赋值给v变量。
     *        2. 如果v值和e值不同，则说明有其它线程已经对v做了更新操作，那么当前线程什么都不做，即更新失败。
     *        3. 当多个线程同时使用CAS操作一个变量时，只会有一个胜出，并成功更新，其它的都会失败。失败的线程不会被挂起，仅会被告知失败，并且允许再次尝试，当然也允许失败的线程做放弃操作。
     *        4. CAS的底层是通过CPU的1条指令来完成3个步骤，因此其本身是一个原子性操作，不存在执行某一个步骤的时候而被中断的可能。
     *        TODO 猜测volatile和CAS操作都属于乐观锁实现方式
     *        【拓展】处理器如何实现原子操作
     *                答: 处理器使用基于对缓存加锁或总线加锁的方式来实现多CPU之间的原子操作。
     *                    1. 总线加锁
     *                       比如i++操作
     *                       众所周知，自增操作不是原子性的，原因在于针对共享变量的读写，线程可能会从共享内存中获取变量值后，拷贝至私有内存进行读写，而私有内存内的数据不会及时的同步至共享内存中。
     *                       处理器使用总线加锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个Lock信号,当一个处理器在总线上输出此信号时，其它的处理器将被阻塞，那么该处理器就可以独占共享内存。
     *                       代价: 总线锁定把CPU和内存之间的通信给锁住了，开销比较大。
     *                    2. 缓存加锁
     *                       缓存一致性协议(MESI) - 参考资料: https://blog.csdn.net/sdr_zd/article/details/81323519
     *
     *  3. volatile关键字的内存语义是什么？
     *      答: volatile的底层其实就是通过LOCK#或缓存锁定实现线程之间的可见性。
     */
}
